"""Semantic Snapshot data models.

These models represent a language-agnostic semantic snapshot of code,
populated from SCIP indexes generated by language-specific indexers.
"""

from __future__ import annotations

from dataclasses import dataclass, field
from enum import Enum
from pathlib import Path
from typing import Any

# =============================================================================
# SCIP Indexer Configuration Models
# =============================================================================


class Language(Enum):
    """Programming languages supported for SCIP indexing."""

    PYTHON = "python"
    TYPESCRIPT = "typescript"
    JAVASCRIPT = "javascript"
    JAVA = "java"
    PHP = "php"


class InstallDepsMode(Enum):
    """Dependency installation mode for indexing."""

    AUTO = "auto"  # Install if lockfile present
    ALWAYS = "always"  # Always install
    NEVER = "never"  # Never install


@dataclass
class ProjectTarget:
    """A detected project root suitable for SCIP indexing."""

    language: Language
    root_path: Path
    metadata: dict[str, Any] = field(default_factory=dict)
    # metadata examples:
    # - python: {"has_pyproject": True, "has_requirements": False}
    # - typescript: {"has_tsconfig": True, "package_manager": "npm"}
    # - java: {"build_tool": "maven", "java_version": "17"}
    # - php: {"has_composer_lock": True}

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "language": self.language.value,
            "root_path": str(self.root_path),
            "metadata": self.metadata,
        }

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> ProjectTarget:
        """Create from dictionary."""
        return cls(
            language=Language(d["language"]),
            root_path=Path(d["root_path"]),
            metadata=d.get("metadata", {}),
        )


@dataclass
class IndexArtifact:
    """Result of running a SCIP indexer on a project."""

    language: Language
    project_root: Path
    scip_path: Path
    logs_path: Path | None
    tool_name: str
    tool_version: str
    duration_s: float
    success: bool = True
    error_message: str | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "language": self.language.value,
            "project_root": str(self.project_root),
            "scip_path": str(self.scip_path),
            "logs_path": str(self.logs_path) if self.logs_path else None,
            "tool_name": self.tool_name,
            "tool_version": self.tool_version,
            "duration_s": self.duration_s,
            "success": self.success,
            "error_message": self.error_message,
        }

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> IndexArtifact:
        """Create from dictionary."""
        return cls(
            language=Language(d["language"]),
            project_root=Path(d["project_root"]),
            scip_path=Path(d["scip_path"]),
            logs_path=Path(d["logs_path"]) if d.get("logs_path") else None,
            tool_name=d["tool_name"],
            tool_version=d["tool_version"],
            duration_s=d["duration_s"],
            success=d.get("success", True),
            error_message=d.get("error_message"),
        )


@dataclass
class IndexConfig:
    """Configuration for SCIP indexing."""

    enabled_languages: set[Language] = field(
        default_factory=lambda: {
            Language.PYTHON,
            Language.TYPESCRIPT,
            Language.JAVASCRIPT,
            Language.JAVA,
            Language.PHP,
        }
    )
    timeout_s_by_language: dict[Language, int] = field(
        default_factory=lambda: {
            Language.PYTHON: 300,
            Language.TYPESCRIPT: 600,
            Language.JAVASCRIPT: 600,
            Language.JAVA: 900,
            Language.PHP: 300,
        }
    )
    install_deps_mode: InstallDepsMode = InstallDepsMode.AUTO
    max_concurrency: int = 2
    output_dir: Path | None = None  # If None, use temp directory
    project_name: str = "project"
    project_version: str = "0.0.0"
    env_overrides: dict[str, str] = field(default_factory=dict)
    # Advanced options
    node_memory_mb: int | None = None  # For TS/JS/Python indexers
    java_build_args: list[str] = field(default_factory=list)
    best_effort: bool = True  # Continue on individual project failures


# =============================================================================
# Semantic Snapshot Models
# =============================================================================


class SymbolKind(Enum):
    """Kind of code symbol."""

    FUNCTION = "function"
    METHOD = "method"
    CLASS = "class"
    STRUCT = "struct"
    INTERFACE = "interface"
    ENUM = "enum"
    TRAIT = "trait"
    TYPE_ALIAS = "type_alias"
    VARIABLE = "variable"
    CONSTANT = "constant"
    MODULE = "module"
    PROPERTY = "property"
    PARAMETER = "parameter"
    UNKNOWN = "unknown"


class OccurrenceRole(Enum):
    """Role of an occurrence in the code."""

    DEFINITION = "definition"
    REFERENCE = "reference"


class RelationKind(Enum):
    """Kind of relationship between symbols."""

    CONTAINS = "contains"  # Parent contains child (class contains method)
    CALLS = "calls"  # Function/method calls another
    REFERENCES = "references"  # General reference
    EXTENDS = "extends"  # Class extends another
    IMPLEMENTS = "implements"  # Class implements interface
    IMPORTS = "imports"  # Module imports another


@dataclass(frozen=True)
class Range:
    """A range in a source file."""

    start_line: int  # 1-indexed
    start_col: int  # 0-indexed
    end_line: int  # 1-indexed
    end_col: int  # 0-indexed

    def to_dict(self) -> dict[str, int]:
        """Convert to dictionary."""
        return {
            "start_line": self.start_line,
            "start_col": self.start_col,
            "end_line": self.end_line,
            "end_col": self.end_col,
        }

    @classmethod
    def from_dict(cls, d: dict[str, int]) -> Range:
        """Create from dictionary."""
        return cls(
            start_line=d["start_line"],
            start_col=d["start_col"],
            end_line=d["end_line"],
            end_col=d["end_col"],
        )


@dataclass
class FileInfo:
    """Information about a source file."""

    path: str
    language: str | None = None

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {"path": self.path, "language": self.language}

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> FileInfo:
        """Create from dictionary."""
        return cls(path=d["path"], language=d.get("language"))


@dataclass
class Symbol:
    """A code symbol definition."""

    def_id: str  # Stable identifier (SCIP ID or path:range:kind for Tree-sitter)
    kind: SymbolKind
    file_path: str
    range: Range
    name: str | None = None
    container_def_id: str | None = None  # Parent symbol's def_id

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "def_id": self.def_id,
            "kind": self.kind.value,
            "file_path": self.file_path,
            "range": self.range.to_dict(),
            "name": self.name,
            "container_def_id": self.container_def_id,
        }

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> Symbol:
        """Create from dictionary."""
        return cls(
            def_id=d["def_id"],
            kind=SymbolKind(d["kind"]),
            file_path=d["file_path"],
            range=Range.from_dict(d["range"]),
            name=d.get("name"),
            container_def_id=d.get("container_def_id"),
        )


@dataclass
class Occurrence:
    """An occurrence of a symbol in code."""

    file_path: str
    range: Range
    role: OccurrenceRole
    def_id: str  # The symbol this occurrence refers to

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "file_path": self.file_path,
            "range": self.range.to_dict(),
            "role": self.role.value,
            "def_id": self.def_id,
        }

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> Occurrence:
        """Create from dictionary."""
        return cls(
            file_path=d["file_path"],
            range=Range.from_dict(d["range"]),
            role=OccurrenceRole(d["role"]),
            def_id=d["def_id"],
        )


@dataclass
class Relation:
    """A relationship between two symbols."""

    src_def_id: str
    kind: RelationKind
    dst_def_id: str
    resolved: bool = True  # False for Tree-sitter unresolved call sites
    weight: float = 1.0
    meta: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "src_def_id": self.src_def_id,
            "kind": self.kind.value,
            "dst_def_id": self.dst_def_id,
            "resolved": self.resolved,
            "weight": self.weight,
            "meta": self.meta,
        }

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> Relation:
        """Create from dictionary."""
        return cls(
            src_def_id=d["src_def_id"],
            kind=RelationKind(d["kind"]),
            dst_def_id=d["dst_def_id"],
            resolved=d.get("resolved", True),
            weight=d.get("weight", 1.0),
            meta=d.get("meta", {}),
        )


@dataclass
class Snapshot:
    """A semantic snapshot of a codebase or portion thereof."""

    files: list[FileInfo] = field(default_factory=list)
    symbols: list[Symbol] = field(default_factory=list)
    occurrences: list[Occurrence] = field(default_factory=list)
    relations: list[Relation] = field(default_factory=list)
    meta: dict[str, Any] = field(default_factory=dict)

    def to_dict(self) -> dict[str, Any]:
        """Convert to dictionary."""
        return {
            "files": [f.to_dict() for f in self.files],
            "symbols": [s.to_dict() for s in self.symbols],
            "occurrences": [o.to_dict() for o in self.occurrences],
            "relations": [r.to_dict() for r in self.relations],
            "meta": self.meta,
        }

    @classmethod
    def from_dict(cls, d: dict[str, Any]) -> Snapshot:
        """Create from dictionary."""
        return cls(
            files=[FileInfo.from_dict(f) for f in d.get("files", [])],
            symbols=[Symbol.from_dict(s) for s in d.get("symbols", [])],
            occurrences=[Occurrence.from_dict(o) for o in d.get("occurrences", [])],
            relations=[Relation.from_dict(r) for r in d.get("relations", [])],
            meta=d.get("meta", {}),
        )

    def merge(self, other: Snapshot) -> Snapshot:
        """Merge another snapshot into this one.

        Useful for combining snapshots from multiple files.
        """
        return Snapshot(
            files=self.files + other.files,
            symbols=self.symbols + other.symbols,
            occurrences=self.occurrences + other.occurrences,
            relations=self.relations + other.relations,
            meta={**self.meta, **other.meta},
        )

    def get_symbol_by_def_id(self, def_id: str) -> Symbol | None:
        """Find a symbol by its def_id."""
        for symbol in self.symbols:
            if symbol.def_id == def_id:
                return symbol
        return None

    def get_symbols_in_file(self, file_path: str) -> list[Symbol]:
        """Get all symbols defined in a file."""
        return [s for s in self.symbols if s.file_path == file_path]

    def get_relations_from(self, def_id: str) -> list[Relation]:
        """Get all relations originating from a symbol."""
        return [r for r in self.relations if r.src_def_id == def_id]

    def get_relations_to(self, def_id: str) -> list[Relation]:
        """Get all relations targeting a symbol."""
        return [r for r in self.relations if r.dst_def_id == def_id]
